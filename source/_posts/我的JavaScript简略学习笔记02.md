---
title: 我的JavaScript简略学习笔记02(运算符)
date: 2019-01-23 21:50:27
tags: [《JavaScript 标准参考教程-阮一峰》,学习笔记]
categories: [学习笔记,JavaScript]
---
# 运算符
## 算数运算符
> JavaScript 共提供10个算术运算符，用来完成基本的算术运算。

+ 加法运算符：`x + y`
+ 减法运算符： `x - y`
+ 乘法运算符： `x * y`
+ 除法运算符：`x / y`
+ 指数运算符：`x ** y //x的y次方`
+ 余数运算符：`x % y`
+ 自增运算符：`++x 或者 x++`
+ 自减运算符：`--x 或者 x--`
+ 数值运算符：`+x`
+ 负数值运算符：`-x`

减法、乘法、除法运算法比较单纯，就是执行相应的数学运算 下面介绍其他几个算术运算符，重点是加法运算符。

### 加法运算符
JavaScript 允许非数值的相加。
+ 布尔值都会自动转成数值，然后再相加。
+ 两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。
+ 一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。
#### 对象的相加
如果运算子是对象，必须先转成原始类型的值，然后再相加。首先，自动调用对象的valueOf方法,一般来说，对象的valueOf方法总是返回对象自身。这时再自动调用对象的toString方法，将其转为字符串。
```js
var obj = { p: 1 };
obj + 2 // "[object Object]2"

var obj = { p: 1 };
obj.valueOf().toString() // "[object Object]"
```
知道了这个规则以后，就可以自己定义valueOf方法或toString方法，得到想要的结果。
``` js
var obj = {
  valueOf: function () {
    return 1;
  }
};

obj + 2 // 3
```
### 余数运算符
需要注意的是，运算结果的正负号由第一个运算子的正负号决定。
```js
-1 % 2 // -1
1 % -2 // 1
```

## 比较运算符
JavaScript 一共提供了8个比较运算符。

+ `>` 大于运算符
+ `<` 小于运算符
+ `<=` 小于或等于运算符
+ `>=` 大于或等于运算符
+ `==` 相等运算符
+ `===` 严格相等运算符
+ `!=` 不相等运算符
+ `!==` 严格不相等运算符

### 非相等运算符
+ 在进行字符串比较时，字符串按照字典顺序进行比较。JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。
+  + 非字符串的比较时，如果两个运算子都是原始类型的值，则是先转成数值再比较。这里需要注意与NaN的比较。任何值（包括NaN本身）与NaN比较，返回的都是false。 
   + 如果运算子是对象，会转为原始类型的值，再进行比较。先调用valueOf方法，如果返回的还是对象，再接着调用toString方法
```js
var x = [2];
x > '11' // true
// 等同于 [2].valueOf().toString() > '11'
// 即 '2' > '11'

x.valueOf = function () { return '1' };
x > '11' // false
// 等同于 [2].valueOf() > '11'
// 即 '1' > '11'

[2] > [1] // true
// 等同于 [2].valueOf().toString() > [1].valueOf().toString()
// 即 '2' > '1'

[2] > [11] // true
// 等同于 [2].valueOf().toString() > [11].valueOf().toString()
// 即 '2' > '11'

{ x: 2 } >= { x: 1 } // true
// 等同于 { x: 2 }.valueOf().toString() >= { x: 1 }.valueOf().toString()
// 即 '[object Object]' >= '[object Object]'
```

### 严格相等运算符
JavaScript 提供两种相等运算符：==和===。

简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。

+ 如果两个值的类型不同，直接返回false。
+ 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。需要注意的是，NaN与任何值都不相等（包括自身）。另外，正0等于负0。
+ 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
+ undefined和null与自身严格相等。

### 相等运算符
+ 相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。
+ 原始类型的值会转换成数值再进行比较。
+ 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。 
+ undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。

相等运算符隐藏的类型转换，会带来一些违反直觉的结果。
```js
0 == ''             // true
0 == '0'            // true

2 == true           // false
2 == false          // false

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
```
上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。

## 布尔运算符
布尔运算符用于将表达式转为布尔值，一共包含四个运算符。

+ 取反运算符：!
+ 且运算符：&&
+ 或运算符：||
+ 三元运算符：?:

### 取反运算符（!）
对于非布尔值，取反运算符会将其转为布尔值。可以这样记忆，以下六个值取反后为true，其他值都为false。

+ undefined
+ null
+ false
+ 0
+ NaN
+ 空字符串（''）
```js
!undefined // true
!null // true
!0 // true
!NaN // true
!"" // true

!54 // false
!'hello' // false
![] // false
!{} // false
```
### 且（或）运算符（&& ||）
如果第一个运算子的布尔值为true，则返回第二个运算子的值（**注意是值，不是布尔值**）；如果第一个运算子的布尔值为false，则直接返回第一个运算子的值，且不再对第二个运算子求值。
> 或运算符（||）同理 也用于多个表达式的求值。它的运算规则是：如果第一个运算子的布尔值为true，则返回第一个运算子的值，且不再对第二个运算子求值；如果第一个运算子的布尔值为false，则返回第二个运算子的值。

~~神奇的JS~~
```js
't' && '' // ""
't' && 'f' // "f"
't' && (1 + 2) // 3
'' && 'f' // ""
'' && '' // ""

't' || '' // "t"
't' || 'f' // "t"
'' || 'f' // "f"
'' || '' // ""

var x = 1;
(1 - 1) && ( x += 1) // 0
x // 1

var x = 1;
true || (x = 2) // true
x // 1
```
有些程序员喜欢用它取代if结构，比如下面是一段if结构的代码，就可以用且运算符改写。
```js
if (i) {
  doSomething();
}

// 等价于

i && doSomething();
```
或运算符常用于为一个变量设置默认值。
```js
function saveText(text) {
  text = text || '';
  // ...
}

// 或者写成
saveText(this.text || '')
```
